\documentclass[11pt, a4paper,titlepage]{report}
\usepackage{geometry}
\usepackage{titlesec}
\usepackage{setspace}
\titleformat{\chapter}[hang] 
{\normalfont\huge\bfseries}{\thechapter:}{1em}{} 
\renewcommand{\labelenumi}{\arabic{enumi}.} 
\renewcommand{\labelenumii}{\arabic{enumi}.\arabic{enumii}}
\renewcommand{\labelenumiii}{\arabic{enumi}.\arabic{enumii}.\arabic{enumiii}}
\geometry{letterpaper}
\usepackage{graphicx}
\usepackage[table]{xcolor}
\usepackage{amssymb}
\usepackage[colorlinks=true,urlcolor=cyan]{hyperref}
\usepackage{mdwlist}
\usepackage{courier}
\usepackage{fancyhdr}
\usepackage{booktabs}
\usepackage{mathtools}
\usepackage[framemethod=TikZ]{mdframed}
\usepackage{amsmath}
\usepackage{subcaption}

\mdfdefinestyle{MyFrame}{%
    outerlinewidth=2pt,
    innertopmargin=\baselineskip,
    innerbottommargin=\baselineskip,
}

\pagestyle{fancy}
\fancyhf{}
\lhead{Project Description for iSESnapchat}
\rhead{\thepage}
%\pagenumbering{arabic}

\usepackage{minted}
\definecolor{bg}{rgb}{0.53,0.54,0.48}
%\setcounter{secnumdepth}{-1}

\title{iSESnapchat}
\author{Cameron Pelkey\\John Reynolds\\Mike Brooks}
\date{November 6, 2013}

\usepackage[backend=bibtex, style=numeric-comp]{biblatex}
\addbibresource{ProjectOutline.bib}



%******************************************************************************
\begin{document}
\maketitle

%\doublespacing

\chapter{Introduction}
\section{Purpose}
This project aimed to produce a secure Snapchat-like client for the Mac OS X operating system.

The project made extensive use of available open source software \emph{OpenSSL} \cite{software:openssl} for the handling and protection of image data, as well as system-level control attributes available within the OS development environment. While the original intention of the project was to use \emph{OpenCV} \cite{software:opencv}, we settled on built-in system image-handling functions instead for ease of implementation.

\section{Motivation}
The mobile application ``Snapchat'' has recently found popularity for its ability to quickly and securely send image and video between users. The novelty of the system lies in the fact users cannot export images or video received and, once viewed, the data persists on the device for only a set length of time after which it is permanently deleted. However a critical flaw in this scheme is that screenshots of received messages may be taken by software imbedded within the mobile device itself, allowing users to easily bypass the security of the application.

Due to restrictions in mobile software capabilities the Snapchat application is unable to intercept the hardware interrupts that that allow the taking of screenshots, limiting the application's ability to respond to merely notifying the sending-party of this action.

Various software applications currently available on the Mac platform provide the user with a means by which to share media between individuals. However, once this media has been sent through a service the user has absolutely no expectation of control over it. No application that we could find provides the functionality of a Snapchat-like application.


\chapter{Overall Description}
\section{Operating Environment}
The program was developed on and for the Mac OS X operating system as a self-contained, stand-alone application.

The choice of working on Mac OS X came primarily as a result of it's availability and ease of development. Most of the group already possessed an extensive prior working-knowledge of development on the OS, while the Unix-like environment provided a necessary level of accessibility to the rest of the group already familiar with such systems.

Additionally, the system came equipped with the development  tools and documentation necessary for properly implementing the system. This allowed not only to rapid development cycles but also simplified the implementation and integration of the necessary sub-systems.

\section{Design and Implementation Constraints}
The system was designed exclusively with the built in system libraries included in the Cocoa development environment. The decision to do this came due to the need for fast implementation and integration of the system as a whole and using these libraries allowed us to be sure that there would be little to no issue making the components work together. The system was written in Objective-C using the XCode development tools, this also aided in the ease of development as the user interface design was streamlined with the help of the UI builder tools within XCode.

\section{System Outline}
\subsection*{High Level Overview}
From a high level standpoint, the application:
\begin{itemize*}
	\item {Present the user with a means of capturing an image for transfer.}
	\item {Allow the user to select a recipient of this image from a list of additional users.}
	\item {Encrypt this image for secure transfer using the RSA public key provided by each of those additional users.}
	\item {Display the image to the recipient using a custom-built viewer so as to prevent the recipient from taking screenshots or otherwise saving this image to the disk.}
	\item {Erase all image data once the allowed viewing time has elapsed.}
\end{itemize*} 

\subsection*{Control Flow}
The normal use case for this program may be divided into two distinct operational components: the taking and encryption of an image, and the subsequent decryption and viewing of that image.

\subsubsection{Image Capture:}
\begin{itemize*}
	\item Open the image capture window.
	\item On capture, ask for user approval.
	\begin{itemize*}
		\item[] If the image is \emph{accepted}:
		\begin{itemize*}
			\item Allow the user to select a recipient from their contacts list.
			\item Encrypt the image, generating a container for the public key of the recipient.
                        \item Provide the user with a file to ship the recipient by the means of their choice.
		\end{itemize*}
		\item[] If the image is \emph{rejected}:
		\begin{itemize*}
			\item Return to the image capture window.
		\end{itemize*}
	\end{itemize*}
\end{itemize*}

\subsubsection{Viewing File:}
\begin{itemize*}
	\item When the user requests to open a chat:
	\begin{itemize*}
        	\item Provide user with a method to select from the file system an snap container.
		\item[] On \emph{file selection}:
		\begin{itemize*}
			\item Decrypt the file to memory, without saving decrypted contents to the disk.
			\item Display the image to the user in a protected window buffer.
			\item Start the view timer for the image.
		\end{itemize*}
		\item[] On \emph{timer finish}:
		\begin{itemize*}
			\item Delete the image from screen, closing the window buffer.
			\item Delete the image contents from memory.
			\item Delete the encrypted content from the disk.
		\end{itemize*}
	\end{itemize*}
\end{itemize*}

\subsection*{User Interface}
The system UI will consist of five distinct components, each within its own display window.
\begin{itemize*}
	\item[] \textbf{Main capture window}
		\begin{itemize*}
			\item[]  Presented on starting the program. Provides the user with a viewing window from which to capture images. This also displays the captured image. Prompts the user to \emph{accept} or \emph{reject} it.
		\end{itemize*}
	\item[] \textbf{Contact List / Recipient selection}
		\begin{itemize*}
			\item[]  Displays the available list of contacts with whom the image may be shared. Each contact listed corresponds to a public key stored in the application directory tree. This component is an Open Dialog, but it does satisfy the conceptual idea of a contact list by keeping the public keys stored in the directory tree.
		\end{itemize*}
	\item[] \textbf{Received images}
		\begin{itemize*}
			\item[]  Displays all encrypted images to be opened by the user. These images are shown as an Open Dialog and allows users to explore their directories to find the encrypted image they wish to open.
		\end{itemize*}
	\item[] \textbf{Secure viewing}
		\begin{itemize*}
			\item[]  Presents the user with a decrypted image within a secure viewing window.
		\end{itemize*}
\end{itemize*}


\chapter{Development}
\section{Working on Mac OS X}
\subsection*{The Programming Environment}
One of the big decisions the group needed to make initially was what language and environment we wanted to build our project on. After doing some research on our options we settled on using Objective-C in the in MAC OSX Cocoa environment. We also decided that we would use Github in order keep a working repository for us to use throughout development.

The use of Objective-C, while in theory being a very good decison, ended up being a much larger learning curve than originally anticipated. Going into the project, John was the only member who had a working knowledge of Objective-C. The other two groupmates had to work to bring themselves up to speed. Cameron was able to do this pretty quickly, but Mike struggled to gain a working knowledge with Objective-C which at times made development strained. The XCode environment did have a lot of tools, such as the Interface Builder, which helped with development. However, if we had to do the project again we may have to think more about which language to proceed with production.

\subsection*{The User Interface}
One of the large benefits of the Developer Tools was the Interface Builder in XCode. The Interface Builder allowed us to create UI components using a tool rather than coding buttons and frames by hand \cite{Hillegass}.

The important benefit of the Interface Builder was the ability stitch our back end functionality to the UI components. This was important because a user needed to perform actions in order to show a picture in our application by using button components. Interface Builder let us do this easily which made it possible to focus heavily on the back end rather than spending a lot of time designing a UI from scratch.

\section{Screenshots}
%reflection on the purpose of the section
The fleeting nature of a message sent via Snapchat is what makes the service so attractive. In theory, a message sent is visible only for the duration the sender intends. This behavior can be thwarted on a mobile device. By taking a screenshot of the current contents of the screen, the user would be able to capture a picture of the message (including window ``chrome'').

The security policy around Snapchat is tailored to the data which Snapchat has the ability to control: the contents of the message. Snapchat only has the ability to control the messages delivered to it, and it has the ability to delete messages. As such, the security policy that Snapchat implements can be expressed as deleting the message from the device.

Obviously, this screenshot-taking action does not break any sort of security policy set forth by Snapchat itself. In fact, Snapchat does not handle screenshots directly. On a mobile device, screenshots are handled by the device's display system, which is married to the operating system. This is to say that the services provided by the device's display system are indistinguishable from the operating system itself, from the app's point of view. To Snapchat's point of view, the message was deleted.

From a meta-policy standpoint, however, the ability to take a screenshot is a fatal flaw in the idea of a message that lasts mere seconds. If the meta-policy is defined as ``a user should only be able to see a message for a limited amount of time'', and the user may take a screenshot of the message, preserving their ability to access the message beyond the time intended, then the meta-policy is being broken by the system being allowed to take screenshots of the content.

\subsection*{Protecting Against Screenshots on the Mac}
%meat and potatoes research
On desktop operating systems (and in our case, the Mac in particular), the operating system grants the application more latitude in how it is displayed. The display system is less tightly bound to the operating system, and the display system can be tweaked to suit the application's specific needs.

In researching this project, we came across an interesting property of the Mac OS X built-in DVD player application. Taking a screenshot of the application does not work. Instead of the still-frame you would expect to be in the screenshot, a grey and white checkerboard %insert image here
is used in place. 

Further research into why the DVD player application does not expose screenshots revealed a property set by the interface that seemed to disallow the window system to allow access to the screen buffer of the player-window. %citation : https://developer.apple.com/library/mac/documentation/Cocoa/Reference/ApplicationKit/Classes/NSWindow_Class/Reference/Reference.html#//apple_ref/c/tdef/NSWindowSharingType

We thought that the windowing system would be unable to expose the contents of the video to whatever part of the system handles screenshots. We were wrong. It turns out that the screenshot mechanism always has access to the contents of the windowing system in recent versions of OS X. DVD player renders video content in graphics memory and merges in the video to the placeholder in the windowing system on its way out to the display. We were unable to replicate this.

Upon realizing that we did not have the resources (time, expertise) to reverse-engineer the DVD-Player method of preventing screenshots, we implemented a method for removing screenshots as they are taken. The program taps into the file-system monitoring capabilities of OS X, and looks for created or modified image files. Any files found are immediately deleted.

\subsection*{Thoughts on Protecting Against Screenshots in Mobile} 
%Dan asked for something on this... May as well start talking about it now...
A few methods could be used to attempt to thwart the use of screen-grabbing a message meant to be temporary. The obvious solution would be for platform-makers (Apple, AOSP, others) to allow for an application to request that the system not be allowed to take screenshots of the active application. Although this solution would be the most globally effective, it would require changes to the platform to work. Alternatively, the screen could be strobed to provide a limited timing window for the attacker to take any screenshot of what would be on the screen -- most of the time, a strobed non-message image.

\subsection*{What About a Camera?}
%thought of this as a case... we do not have to implement this... but it would be a good thing to start talking about.

Screenshots are only part of the problem. In both cases, desktop and mobile, not only can the user take a screenshot of the message, but they can also take a picture of the physical device (with a message on-screen) with a camera. If taking a screenshot of the screen violated metapolicy, then taking a picture of the screen certainly does too. 

There are a number of solutions that could be used to solve this. The first would be to make the contents of the screen obscure such that a camera would have a hard time capturing the image. This could be accomplished by dimming the image or strobing a black overlay on top of the image. These methods rely on the quality of the camera, and the ability of the adversary to time pictures being taken. Both methods are also inherently passive.

Alternately, a more active approach could be taken, where the app on a mobile device or an application on a proper computer could use cameras available to watch for cameras. This method would require computer vision techniques to create an ``imaging device identifier''. In theory, if the application were forced to run on screens with a camera attached (usually the main screen), then the application could watch for imaging devices pointed at the screen, and blank the screen if such an imaging device were suspected. 

\section{Concluding Remarks}
At the progress point, we wrote that:\\

\noindent\emph{A large portion of work thus far has been in bringing ourselves up to speed. After reading Objective-C and MAC OS X documentation we feel confident that we will be able to become fluent in a short period of time. We hope that this choice will allow us to implement our project in an efficient manner, and hopefully leave time to play around with additional functionality.}\\

While we were unable to provide all functionality as promised, we feel that our final product is an excellent proof of concept of secure picture messaging. While some functions are left up to the user, we believe that the core functionality that we aimed to provide was accomplished. Further effort could be applied to satisfy less-critical design specifications to make the user interface more usable, and to provide message transmission more reliable than ``via means provided by the user'' (eg. email, physical media-passing, etc). Further work in graphics programming for this could yield a truly novel product - one that actively blocks screenshots.

\printbibliography 
\nocite{*}
\end{document}

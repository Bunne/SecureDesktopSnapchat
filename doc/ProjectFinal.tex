\documentclass[11pt, a4paper,titlepage]{report}
\usepackage{geometry}
\usepackage{titlesec}
\usepackage{setspace}
\titleformat{\chapter}[hang] 
{\normalfont\huge\bfseries}{\thechapter:}{1em}{} 
\renewcommand{\labelenumi}{\arabic{enumi}.} 
\renewcommand{\labelenumii}{\arabic{enumi}.\arabic{enumii}}
\renewcommand{\labelenumiii}{\arabic{enumi}.\arabic{enumii}.\arabic{enumiii}}
\geometry{letterpaper}
\usepackage{graphicx}
\usepackage[table]{xcolor}
\usepackage{amssymb}
\usepackage[colorlinks=true,urlcolor=cyan]{hyperref}
\usepackage{mdwlist}
\usepackage{courier}
\usepackage{fancyhdr}
\usepackage{booktabs}
\usepackage{mathtools}
\usepackage[framemethod=TikZ]{mdframed}
\usepackage{amsmath}
\usepackage{subcaption}

\mdfdefinestyle{MyFrame}{%
    outerlinewidth=2pt,
    innertopmargin=\baselineskip,
    innerbottommargin=\baselineskip,
}

\pagestyle{fancy}
\fancyhf{}
\lhead{Project Description for iSESnapchat}
\rhead{\thepage}
%\pagenumbering{arabic}

\usepackage{minted}
\definecolor{bg}{rgb}{0.53,0.54,0.48}
%\setcounter{secnumdepth}{-1}

\title{iSESnapchat}
\author{Cameron Pelkey\\John Reynolds\\Mike Brooks}
\date{November 6, 2013}

\usepackage[backend=bibtex, style=numeric-comp]{biblatex}
\addbibresource{ProjectOutline.bib}



%******************************************************************************
\begin{document}
\maketitle

%\doublespacing

\chapter{Introduction}
\section{Purpose}
This project aims to produce a secure Snapchat-like client for the Mac OS X operating system.

The project makes extensive use of available open source software \emph{OpenCV} \cite{software:opencv} and \emph{OpenSSL} \cite{software:openssl} for the handling and protection of image data, as well as system-level control attributes available within the OS development environment.

\section{Motivation}
The mobile application ``Snapchat'' has recently found popularity for its ability to quickly and securely send image and video between users. The novelty of the system lies in the fact users cannot export images or video received and, once viewed, the data persists on the device for only a set length of time after which it is permanently deleted. However a critical flaw in this scheme is that screenshots of received messages may be taken by software imbedded within the mobile device itself, allowing users to easily bypass the security of the application.

Due to restrictions in mobile software capabilities the Snapchat application is unable to intercept the hardware interrupts that that allow the taking of screenshots, limiting the application's ability to respond to merely notifying the sending-party of this action.

Various software applications currently available on the Mac platform provide the user with a means by which to share media between individuals. However, once this media has been sent through a service the user has absolutely no expectation of control over it. No application presently available provides the functionality of a Snapchat-like application.


\chapter{Overall Description}
\section{Operating Environment}
The program is being developed on and for the Mac OS X operating system as a self-contained, stand-alone application.

The choice of working on Mac OS X came primarily as a result of it's availability and ease of development. Most of the group already possessed an extensive prior working-knowledge of development on the OS, while the Unix-like environment provided a necessary level of accessibility to the rest of the group already familiar with such systems.

Additionally, the system comes equipped with the development  tools and documentation necessary for properly implementing the system being designed. This lends not only to rapid development cycles but also simplifies the process for building and integrating necessary sub-systems.

\section{Design and Implementation Constraints}
The system is developed with and requires \emph{OpenCV Version 2.4.6} and \emph{OpenSSL-1.0.1e}. \emph{CMake} \cite{software:cmake} is required to install OpenCV into the project. The \emph{openssl-xcode} \cite{software:ssl-xcode} project is required in conjunction with OpenSSL to build the static libcrypto.a library for integration with the system. \emph{Xcode} is required to build the system.

While the project itself is implemented in Objective-C, the project dependencies OpenCV and OpenSSL are implemented in C++ and C, respectively. Objective-C is primarily used for creating the necessary graphical user interface and protected windowing system for displaying images. C++ and C code may be integrated into and called from within Objective-C code files with no issue.

\section{System Outline}
\subsection*{High Level Overview}
From a high level standpoint, application will:
\begin{itemize*}
	\item {Present the user with a means of capturing or selecting an image for transfer.}
	\item {Allow the user to select one or more recipients of this image from a list of additional users.}
	\item {Encrypt this image for secure transfer using the RSA public key provided by each of those additional users.}
	\item {Display the image to the recipient using a custom-built viewer so as to prevent the recipient from taking screenshots or otherwise saving this image to the disk.}
	\item {Erase all image data once the allowed viewing time has elapsed.}
\end{itemize*} 

\subsection*{Control Flow}
The normal use case for this program may be divided into two distinct operational components: the taking and encryption of an image, and the subsequent decryption and viewing of that image.

\subsubsection{Image Capture:}
\begin{itemize*}
	\item Open the image capture window.
	\item On capture, ask for user approval.
	\begin{itemize*}
		\item[] If the image is \emph{accepted}:
		\begin{itemize*}
			\item Allow the user to select $n$ recipients from their contacts list.
			\item Encrypt the image $n$ times, generating a separate encrypted image for each public key of each contact.
			\item Ship the encrypted files to the recipients.
		\end{itemize*}
		\item[] If the image is \emph{rejected}:
		\begin{itemize*}
			\item Return to the image capture window.
		\end{itemize*}
	\end{itemize*}
\end{itemize*}

\subsubsection{Viewing File:}
\begin{itemize*}
	\item Present the user with a list of received, encrypted files to open.
	\begin{itemize*}
		\item[] On \emph{file selection}:
		\begin{itemize*}
			\item Decrypt the file to memory, without saving decrypted contents to the disk.
			\item Display the image to the user in a protected window buffer.
			\item Start the view timer for the image.
		\end{itemize*}
		\item[] On \emph{timer finish}:
		\begin{itemize*}
			\item Delete the image from screen, closing the window buffer.
			\item Delete the image contents from memory.
			\item Delete the encrypted content from the disk.
		\end{itemize*}
	\end{itemize*}
\end{itemize*}

\subsection*{User Interface}
The system UI will consist of five distinct components, each within its own display window.
\begin{itemize*}
	\item[] \textbf{Main capture window}
		\begin{itemize*}
			\item[]  Presented on starting the program. Provides the user with a viewing window from which to capture images.
		\end{itemize*}
	\item[] \textbf{Image approval}
		\begin{itemize*}
			\item[]  Displays the captured image. Prompts the user to \emph{accept} or \emph{reject} it.
		\end{itemize*}
	\item[] \textbf{Contact List / Recipient selection}
		\begin{itemize*}
			\item[]  Displays the available list of contacts with whom the image may be shared. Each contact listed corresponds to a public key stored in the application directory tree.
		\end{itemize*}
	\item[] \textbf{Received images}
		\begin{itemize*}
			\item[]  Displays all encrypted images to be opened by the user. These images are also stored within the application directory tree.
		\end{itemize*}
	\item[] \textbf{Secure viewing}
		\begin{itemize*}
			\item[]  Presents the user with a decrypted image within a secure viewing window. This window prevents any external processes from reading its contents, effectively preventing any sort of screen capture.
		\end{itemize*}
\end{itemize*}


\chapter{Development}
\section{Working on Mac OS X}
\subsection*{The Programming Environment}
One of the big decisions the group needed to make initially was what language and environment we wanted to build our project on. After doing some research on our options we settled on using Objective-C in the in MAC OSX Cocoa environment. We also decided that we would use Github in order keep a working repository for us to use throughout development.

One of the large benefits to Objective-C is that, even though not everyone in our group has worked with it, we have all done a mixture of C programming and object oriented programming. Objective-C combines these worlds by extending the C programming language in such a way that makes it an object oriented language \cite{Hillegass}. This will help us in our project by allowing us to access lower level details that are offered in C, as well as have the elegance of creating classes and objects that suite our needs as we may do in Java.

Developing on the Mac OS X using Cocoa will give us access to development tools such as XCode and Instruments, which come standard as part of the Mac OS X Developer Tools \cite{Hillegass}. These tools will offer us the resources we need in order to implement our project very efficiently by allowing us an IDE to work in, as well as debugging tools to fix any various errors. Cocoa also offers collections of classes and functionality in packages called frameworks \cite{Hillegass}. We hope to be able to use these Cocoa frameworks to implement various functionality that we wish to utilize rather than having to write those components by scratch.

\subsection*{The User Interface}
One of the large benefits of the Developer Tools is the Interface Builder that is in XCode. The Interface Builder allows us to create UI components using a tool rather than coding buttons and frames by hand \cite{Hillegass}. The UI components in MAC OS X are represented utilizing XIB. XIB is simply a representation of XML \cite{Hillegass}. When we create our user interface XCode handles all of the saving of the components in the XIB, allowing us to concentrate more on the design portion.

The important benefit of the Interface Builder is that we can also stitch our back end functionality to the UI components, which will also be saved to the XIB by XCode \cite{Hillegass}. This will be important because a user will need to perform actions in order to show a picture in our application by using button components. Interface Builder lets us do this easily which makes it possible to focus heavily on the back end rather than spending a lot of time designing a UI from scratch.

\section{Screenshots}
%reflection on the purpose of the section
The fleeting nature of a message sent via Snapchat is what makes the service so attractive. In theory, a message sent is visible only for the duration the sender intends. This behavior can be thwarted on a mobile device. By taking a screenshot of the current contents of the screen, the user would be able to capture a picture of the message (including window ``chrome'').

The security policy around Snapchat is tailored to the data which Snapchat has the ability to control: the contents of the message. Snapchat only has the ability to control the messages delivered to it, and it has the ability to delete messages. As such, the security policy that Snapchat implements can be expressed as deleting the message from the device.

Obviously, this screenshot-taking action does not break any sort of security policy set forth by Snapchat itself. In fact, Snapchat does not handle screenshots directly. On a mobile device, screenshots are handled by the device's display system, which is married to the operating system. This is to say that the services provided by the device's display system are indistinguishable from the operating system itself, from the app's point of view. To Snapchat's point of view, the message was deleted.

From a meta-policy standpoint, however, the ability to take a screenshot is a fatal flaw in the idea of a message that lasts mere seconds. If the meta-policy is defined as ``a user should only be able to see a message for a limited amount of time'', and the user may take a screenshot of the message, preserving their ability to access the message beyond the time intended, then the meta-policy is being broken by the system being allowed to take screenshots of the content.

\subsection*{Protecting Against Screenshots on the Mac}
%meat and potatoes research
On desktop operating systems (and in our case, the Mac in particular), the operating system grants the application more latitude in how it is displayed. The display system is less tightly bound to the operating system, and the display system can be tweaked to suit the application's specific needs.

In researching this project, we came across an interesting property of the Mac OS X built-in DVD player application. Taking a screenshot of the application does not work. Instead of the still-frame you would expect to be in the screenshot, a grey and white checkerboard %insert image here
is used in place. The windowing system seems to be unable to expose the contents of the video to whatever part of the system handles screenshots.

Further research into why the DVD player application does not expose screenshots revealed a property set by the interface that disallows the window system to allow access to the screen buffer of the player-window. %citation : https://developer.apple.com/library/mac/documentation/Cocoa/Reference/ApplicationKit/Classes/NSWindow_Class/Reference/Reference.html#//apple_ref/c/tdef/NSWindowSharingType
By using this window property, we should be able to block access to the contents of our message from other processes, to include the process that takes a screen grab.

What needs to be done is test corner cases: in the event that a screenshot were taken as root, would the window property discussed above still protect the message, or have we found a hole in the window manager's window sharing policies? This is a subject that still needs testing. 

\subsection*{Thoughts on Protecting Against Screenshots in Mobile} 
%Dan asked for something on this... May as well start talking about it now...
A few methods could be used to attempt to thwart the use of screen-grabbing a message meant to be temporary. The obvious solution would be for platform-makers (Apple, AOSP, others) to allow for an application to request that the system not be allowed to take screenshots of the active application. Although this solution would be the most globally effective, it would require changes to the platform to work. Alternatively, the screen could be strobed to provide a limited timing window for the attacker to take any screenshot of what would be on the screen -- most of the time, a strobed non-message image.

\subsection*{What About a Camera?}
%thought of this as a case... we do not have to implement this... but it would be a good thing to start talking about.

Screenshots are only part of the problem. In both cases, desktop and mobile, not only can the user take a screenshot of the message, but they can also take a picture of the physical device (with a message on-screen) with a camera. If taking a screenshot of the screen violated metapolicy, then taking a picture of the screen certainly does too. 

There are a number of solutions that could be used to solve this. The first would be to make the contents of the screen obscure such that a camera would have a hard time capturing the image. This could be accomplished by dimming the image or strobing a black overlay on top of the image. These methods rely on the quality of the camera, and the ability of the adversary to time pictures being taken. Both methods are also inherently passive.

Alternately, a more active approach could be taken, where the app on a mobile device or an application on a proper computer could use cameras available to watch for cameras. This method would require computer vision techniques to create an ``imaging device identifier''. In theory, if the application were forced to run on screens with a camera attached (usually the main screen), then the application could watch for imaging devices pointed at the screen, and blank the screen if such an imaging device were suspected. 

\section{Concluding Remarks}
A large portion of work thus far has been in bringing ourselves up to speed. After reading Objective-C and MAC OS X documentation we feel confident that we will be able to become fluent in a short period of time. We hope that this choice will allow us to implement our project in an efficient manner, and hopefully leave time to play around with additional functionality.

\chapter{Final Deliverable}
The final deliverable for this project will be an implemented, demonstrable Snapchat-like system with an accompanying evaluation of the security measures demonstrated and their impact.
\section{Current Progress}
The majority of our efforts up to this point have been spent on performing preliminary research and learning the necessary APIs for implementing this system.

As shown in this document, we also have a clear understanding of what this project is and will be. By spending as much time focusing on this preliminary work and planning, we have a defined goal for this project, and we are now able to begin safely and efficiently producing a working product.

We currently have a working system with \emph{OpenCV} and \emph{OpenSSL} integrated directly. Programming has already begun on the necessary sub-tasks such as image capture, display as well as in-place encryption and decryption.


\printbibliography 
\nocite{*}
\end{document}
